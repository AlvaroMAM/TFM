one sig UseCase extends Hybrid_Deployment {}
</
    enum status_analysis:{none, initial, launchAnalysis, waitingResults,done};
    var current_status:[status_analysis] init none;
    var AggregatorServiceInvoked : bool init false;
    var machineCost:[0..500] init 0;
    var workflowDone: bool init false;
    [launch] (current_status=initial) -> (current_status'=launchAnalysis);
    // 1. Launching Analysis
    [Aggregator:activationCall] (current_status=launchAnalysis) & (!AggregatorServiceInvoked) -> (AggregatorServiceInvoked'=true) & (current_status'=waitingResults); // Se sincroniza con aggregator
    [ResultProcessor:showQuantumResults] (current_status=waitingResults) & (AggregatorServiceInvoked) -> (current_status'=done) & (workflowDone'=true);
/>

abstract sig Aggregator extends Classical_Service {}
</
    formula performance;
    formula availability;
    formula cost;
    enum status_aggregator:{initial, dataCollection, transformingData, groverCall, launchGrover, done, none};
    var serviceOK: bool init false;
    var ready : bool init true;
    var DataServiceInvoked : bool init false;
    var GroverClassicalServiceInvoked : bool init false;
    var current_status:[status_aggregator] init none;

    //Calcular coste y rendimiento según la máquina con la que esté relacionada
    [machines:cpair] (current_status=none) -> (cost'=machines.machineCost*availability) & (performance'=4) & (current_status'=initial);
    [DeploymentWorkFlow:activationCall] (ready) -> (serviceOK'=true) & (ready'=false);
    [DataService:requestDataCall] (!ready) & (serviceOK) & (!DataService1Invoked) & (current_status=init) -> (DataServiceInvoked'=true) & (current_status'=dataCollection);
    [DataService:requestData] (!ready) & (serviceOK) & (DataServiceInvoked) & (current_status=dataCollection) -> (current_status'=transformingData);
    [] (DataServiceInvoked) & (current_status=transformingData) -> (current_status'=groverCall);
    [ClassicalGrover:launchGroverCall] (current_status=groverCall) & (!GroverClassicalServiceInvoked)-> (current_status'=launchGrover) & (GroverClassicalServiceInvoked'=true);
    [ClassicalGrover:launchGrover] (GroverClassicalServiceInvoked) & (current_status=launchGrover) -> (current_status'=done) & (ready'=false) & (serviceOK'=false); // Aquí terminaria

    // Sumar solo las propiedades cuando se ejecuta
    reward performanceRew [ClassicalGrover:launchGrover] true : performance;
    reward costRew [ClassicalGrover:launchGrover] true : cost;
/>

abstract sig DataService extends Classical_Service {}
</
    enum status_dataservice:{initial, dataCollection, transformingData, groverCall, launchGrover, done, none};
    formula performance;
    formula availability;
    formula cost;
    var serviceOK: bool init false;
    var ready : bool init true;
    var current_status:[status_dataservice] init none;
    //[nombrerelacion:nombrefuncion]
    [machines:cpair] (current_status=none) -> (cost'=machines.machineCost*availability) & (performance'=1) & (current_status'=initial);
    [Aggregator:requestDataCall] (ready) -> (serviceOK'=true) & (ready'=false); // Creo que esta linea no es necesaria en este caso de estudio porque no se está teniendo en cuenta el éxito en las llamadas
    [Aggregator:requestData] (!ready) & (serviceOK) -> (ready'=true) & (serviceOK'=false);

    // Sumar solo las propiedades cuando se ejecuta
    reward performanceRew [Aggregator:requestData] true : performance;
    reward costRew [Aggregator:requestData] true : cost; 
/>

abstract sig ClassicalGrover extends Classical_Service {}
</ // Debe tener transiciones síncronas con quantum grover y processing_result services
    formula performance;
    formula availability;
    formula cost;
    var serviceOK: bool init false;
    var ready : bool init true;
    enum status_classical_grover:{initial, circuitBuilding, groverLaunch, resultRecovery, launchProcessingResult, done, none};
    var current_status:[status_classical_grover] init none;
    var GroverQuantumServiceInvoked : bool init false;
    var ResultProcessingServiceInvoked : bool init false;

    [machines:cpair] (current_status=none) -> (cost'=machines.machineCost*availability) & (performance'=1) & (current_status'=initial);
    [Aggregator:launchGroverCall] (ready) -> (serviceOK'=true) & (ready'=false);
    [Aggregator:launchGrover] (!ready) & (serviceOK) -> (current_status'=circuitBuilding);
    [] (!ready) & (serviceOK) & (current_status=circuitBuilding) -> (current_status'=groverLaunch);
    [QuantumGrover:launchGroverCall] (!ready) & (serviceOK) & (current_status=groverLaunch) & (!GroverQuantumServiceInvoked) -> (GroverQuantumServiceInvoked'=true);
    [QuantumGrover:launchGrover] (!ready) & (serviceOK) & (current_status=groverLaunch) & (GroverQuantumServiceInvoked) -> (current_status'=resultRecovery);
    [QuantumGrover:results] (!ready) & (serviceOK) & (GroverQuantumServiceInvoked) & (current_status=resultRecovery) -> (current_status'=launchProcessingResult);
    [ResultProcessor:resultsRecievedCall] (!ready) & (serviceOK) & (GroverQuantumServiceInvoked) & (current_status=resultRecovery) & (!ResultProcessingServiceInvoked)-> (ResultProcessingServiceInvoked'=true);
    [ResultProcessor:resultsRecieved] (!ready) & (serviceOK) & (GroverQuantumServiceInvoked) & (current_status=launchProcessingResult) & (ResultProcessingServiceInvoked) -> (current_status'=done) & (ready'=true) & (serviceOK'=false); // Termina el proceso Clásico de grover

    // Sumar solo las propiedades cuando se ejecuta
    reward performanceRew [ResultProcessor:resultsRecieved] true : performance;
    reward costRew [ResultProcessor:resultsRecieved] true : cost; 
/>

abstract sig QuantumGrover extends Quantum_Service{}
</
    formula cost;
    formula shots;
    enum status_quantum_grover:{initial, enqueue, executing, done, none};
    var serviceOK: bool init false;
    var ready : bool init true;
    var current_status:[status_quantum_grover] init none;
    [machines:qpair] (current_status=none) -> (cost'=machines.machineCost*shots) & (current_status'=initial);
    [ClassicalGrover:launchGroverCall] (current_status=initial) & (ready) -> (serviceOK'=true) & (ready'=false);
    [ClassicalGrover:launchGrover] (current_status=initial) & (!ready) & (serviceOK) -> (current_status'=enqueue);
    [] (current_status=enqueue) & (!ready) & (serviceOK) -> 0.5: (current_status'=enqueue) + 0.5 (current_status'=executing); // Simulating A Queue with probabilistic execution
    [] (current_status=executing) & (!ready) & (serviceOK) -> (current_status'=done); // Simulating A Queue with probabilistic execution
    [ClassicalGrover:results] (current_status'=done) & (!ready) & (serviceOK) -> (ready'=true) & (serviceOK'=false);

    // Sumar solo las propiedades cuando se ejecuta
    reward performanceRew [ClassicalGrover:results] true : performance;
    reward costRew [ClassicalGrover:results] true : cost;
/>

abstract sig ResultProcessor extends Classical_Service {}
</
    formula performance;
    formula availability;
    formula cost;
    enum status_processor:{init, recievingResult, processingResult, resultsReady, done, none};
    var serviceOK: bool init false;
    var ready : bool init true;
    var current_status:[status_processor] init none;
    [machines:cpair] (current_status=none) -> (cost'=machines.machineCost*availability) & (performance'=1) & (current_status'=initial);
    [ClassicalGrover:resultsRecievedCall] (ready) -> (serviceOK'=true) & (ready'=false); 
    [ClassicalGrover:resultsRecieved] (!ready) & (serviceOK) -> (current_status'=recievingResult);
    [] (!ready) & (serviceOK) & (current_status=recievingResult) ->  (current_status'=processingResult);
    [] (!ready) & (serviceOK) & (current_status=processingResult) ->  (current_status'=resultsReady);
    [DeploymentWorkFlow:showQuantumResults] (current_status=resultReady) & (!ready) & (serviceOK) -> (current_status'=done) & (ready'=true) & (serviceOK'=false);

    // Sumar solo las propiedades cuando se ejecuta
    reward performanceRew [DeploymentWorkFlow:showQuantumResults] true : performance;
    reward costRew [DeploymentWorkFlow:showQuantumResults] true : cost;

/>