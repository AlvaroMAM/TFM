
//	Alumno: Álvaro Manuel Aparicio Morales
//	Tutores: Javier Cámara y Jose Garcia-Alonso
//	Máster Universitario en Ingeniería Informática
//	Universidad de Málaga
//	Descripcion:
//	Especificación del modelo arquitectural de aplicaciones híbridas (clásico-cuánticas)


abstract sig PU {services : some Service}
</
formula cpu_logical_performance_factor;
formula cpu_ram;
formula cpu_bandwidth;
formula cpu_cost_factor;
formula qpu_prize;

/>
abstract sig QPU extends PU {}
</
formula cpu_logical_performance_factor;
formula cpu_ram;
formula cpu_bandwidth;
formula cpu_cost_factor;
formula qpu_prize;
[services:pair] true -> true;
/>
abstract sig CPU extends PU {}
</
formula cpu_logical_performance_factor;
formula cpu_ram;
formula cpu_bandwidth;
formula cpu_cost_factor;
formula qpu_prize;
[services:pair] true -> true;
/>
abstract sig Service {
	machines : some PU,
	deployment : one Deployment,
	hybrid_service: set Service, // Simular el concepto de hybrid_service
	link: some Service // Comunicación entre servicios del caso de uso
}
</
    formula ms_logical_performance_factor;
    formula ms_ram;
    formula ms_bandwidth;
    formula ms_execution_time;
    formula ms_availability;
    formula shots;
    formula performance;
    formula cost;
    enum status_microservice:{initial, done, none};
    var current_status:[status_microservice] init none;
/>
abstract sig Classical_Service extends Service {}
</
    formula ms_logical_performance_factor;
    formula ms_ram;
    formula ms_bandwidth;
    formula ms_execution_time;
    formula ms_availability;
    formula shots;
    formula performance;
    formula cost;
    enum status_microservice:{initial, done, none};
    var current_status:[status_microservice] init none;
/>
abstract sig Quantum_Service extends Service {}
</
    formula ms_logical_performance_factor;
    formula ms_ram;
    formula ms_bandwidth;
    formula ms_execution_time;
    formula ms_availability;
    formula shots;
    formula performance;
    formula cost;
    enum status_microservice:{initial, done, none};
    var current_status:[status_microservice] init none;
/>
abstract sig Deployment {services: some Service}
</
    enum status_analysis:{none, launchAnalysis, done};
    var current_status:[status_analysis] init none;
    var workflowDone: bool init false;
/>
abstract sig Hybrid_Deployment extends Deployment {}
</
    enum status_analysis:{none, launchAnalysis, done};
    var current_status:[status_analysis] init none;
    var workflowDone: bool init false;

    [] (current_status=none) -> (current_status'=launchAnalysis);
    // 1. Launching Analysis
    [services:activationCall] (current_status=launchAnalysis) -> (workflowDone'=true) & (current_status'=done);
/>
abstract sig Classical_Deployment extends Deployment {}
</
    enum status_analysis:{none, launchAnalysis, done};
    var current_status:[status_analysis] init none;
    var workflowDone: bool init false;

    [] (current_status=none) -> (current_status'=launchAnalysis);
    // 1. Launching Analysis
    [services:activationCall] (current_status=launchAnalysis) -> (workflowDone'=true) & (current_status'=done);
/>
lone sig HybridUseCase extends Hybrid_Deployment {}
</
    enum status_analysis:{none, launchAnalysis, done};
    var current_status:[status_analysis] init none;
    var workflowDone: bool init false;
/>
lone sig ClassicalUseCase extends Classical_Deployment {}
</
    enum status_analysis:{none, launchAnalysis, done};
    var current_status:[status_analysis] init none;
    var workflowDone: bool init false;
/>

fact {
//-------------------------------------------- Architectural-Restrictions ------------------------------------------------------

//-------------------------------------------- Machines- Restrictions------------------------------------------------------
// Toda máquina debe estar asociada a algún servicio
all pu: PU | #pu.services > 0
// Si un servicio está desplegado en una máquina, entonces esa máquina solo puede estar relacionada con ese servicio
all pu: PU, s: Service | s in pu.services implies s.machines = pu
// Para todas las máquinas clásicas, su conjunto de servicios no pueden ser cuánticos
all c: CPU | #(c.services & Quantum_Service) = 0
// Todos los servicios deben de estar asociados a un despliege
// Para todas las máquinas clásicas, su conjunto de servicios no pueden ser cuánticos
all q: QPU | #(q.services & Classical_Service) = 0
//-------------------------------------------------------------------------------------------------------------------------

//-------------------------------------------- Services- Restrictions------------------------------------------------------
//all s: Service | #(s.deployment) = 1 // Ya se cumple
all s: Service | #(s.deployment & Hybrid_Deployment) = 0 implies #(s.hybrid_service) = 0
// Todo servicio tiene que estar asociado a un despliegue. Aquí se define para ambos lados, desde servicios y desde despliegue
all s: Service, d: Deployment | (s in d.services implies d in s.deployment) and (s.deployment = d implies s in d.services)
// Ningún servicio puede estar relacionado consigo mismo
all s: Service | s not in s.link
//-------------------------------------------------------------------------------------------------------------------------

//------------------------------------------- Classical-Restrictions-------------------------------------------------- 
// Un servicio clásico, no puede relacionarse con una máquina cuántica
all cs: Classical_Service | #(cs.machines & QPU) = 0
// Un servicio clásico, no puede estar alojado en una misma instancia de máquina clásica que otro servicio clásico (No co-alojados)
all cs1, cs2 : Classical_Service | cs1 != cs2 implies #(cs1.machines & cs2.machines) = 0
// Un servicio clásico, no puede estar alojado en la misma instancia de máquina clásica que un servicio híbrido (Se cumple con la anterior)
// Un servicio clásico, no puede estar relacionado con más de una instancia de máquina clásica.
all sc: Classical_Service | #sc.machines < 2
// Un servicio clásico, tiene que tener una instancia de máquina clásica asociada.
all sc: Classical_Service | #sc.machines > 0
//----------------------------------------------------------------------------------------------------------------------------

//--------------------------------------------- Quantum-Restrictions-------------------------------------------------
// Un servicio cuántico, no puede estar alojado en una máquina clásica
all qs: Quantum_Service | #(qs.machines & CPU) = 0
// Un servicio cuántico, no puede estar alojado en más de una máquina cuántica
all qs: Quantum_Service | #qs.machines < 2
//Un servicio cuántico, tiene que tener una instancia de máquina cuántica asociada.
all qs: Quantum_Service | #qs.machines > 0
// Un servicio cuántico, no puede estar en un despliegue clásico
//all qs: Quantum_Service | #(qs.deployment & Classical_Deployment) = 0
// Toda máquina cuántica debe tener un servicio asociado
all qs: Quantum_Service, q: QPU | qs.machines = q implies qs in q.services
// Todo servicio cuántico debe tener un servicio clásico asociado
all qs: Quantum_Service | #(qs.hybrid_service) = 1  and #(qs.hybrid_service & Quantum_Service) = 0

//-----------------------------------------------------------------------------------------------------------------------------

//----------------------------------------Hybrid-Services-Restrictions----------------------------------------------------------
// Todo servicio cuántico tiene que estar asociado a un servicio clásico 
all qs: Quantum_Service | qs in Classical_Service.hybrid_service
// Para todos los servicios clásicos y cuánticos que conforman un servicio híbrido, deben pertenecer al mismo despliegue
all s1, s2: Service | s1 !=s2 and s1 in s2.hybrid_service and s2 in s1.hybrid_service implies s1.deployment = s2.deployment
// Un servicio cuántico no puede compartir el servicio clásico con el que está asociado
all qs1, qs2: Quantum_Service | qs1 != qs2 and #(qs1.hybrid_service) = 1 and #(qs2.hybrid_service) = 1 implies #(qs1.hybrid_service & qs2.hybrid_service) = 0
// El servicio cuántico y clásico que conformen un servicio híbrido, solo pueden estar relacionado entre ellos
all qs:Quantum_Service, cs: Classical_Service | (cs in qs.hybrid_service implies qs in cs.hybrid_service) and (qs in cs.hybrid_service implies cs in qs.hybrid_service)
// Dos servicios clásicos no pueden formar un servicio híbrido. Un servicio consigo mismo tampoco puede formar un servicio híbrido
all cs1, cs2: Classical_Service, hd: Hybrid_Deployment | (cs1 in hd.services and cs2 in hd.services) implies not (cs1 in cs2.hybrid_service) and not ( cs2 in cs2.hybrid_service)
// Dos servicios forman un servicio híbrido, entonces esos dos están relacionados a través de link
all s1, s2: Service | s1 !=s2 and s1 in s2.hybrid_service and s2 in s1.hybrid_service implies (s2 in s1.link and s1 in s2.link)
//--------------------------------------------------------------------------------------------------------------------------------

//--------------------------------------------------Deployment-Restrictions-------------------------------------------------
// Para todo despliegue si la interseccion con Hybrido entonces no clasico y viceversa
//all d: Deployment | #(d & Hybrid_Deployment) > 0 implies  #(d & Classical_Deployment) = 0 
//all d: Deployment | #(d & Classical_Deployment) > 0 implies  #(d & Hybrid_Deployment) = 0 
// Todos los servicios deben de pertenecer a un despliegue (Se cumple con el one en Deployment)
all hd: Hybrid_Deployment | #(hd.services & Quantum_Service) > 0 and #(hd.services & Classical_Service) > 0
all cd: Classical_Deployment | #(cd.services & Quantum_Service) = 0
//---------------------------------------------------------------------------------------------------------------------------
 
}
abstract sig Aggregator extends Classical_Service {}
</
    formula ms_logical_performance_factor;
    formula ms_ram;
    formula ms_bandwidth;
    formula ms_execution_time;
    formula ms_availability;
    formula shots;
    formula performance;
    formula cost;
    enum status_microservice:{initial, done, none};
    var current_status:[status_microservice] init none;
    [machines:pair] (current_status=none) -> (cost'=machines.cpu_cost_factor*ms_availability + machines.qpu_prize*shots) & (performance'=((ms_logical_performance_factor/machines.cpu_logical_performance_factor)+(ms_ram/machines.cpu_ram)+(ms_bandwidth/machines.cpu_bandwidth))/3) & (current_status'=initial);
    [deployment:activationCall] (current_status=initial) -> (current_status'=done);

    // Sumar solo las propiedades cuando se ejecuta
    reward performanceRew [deployment:activationCall] true : performance;
    reward costRew [deployment:activationCall] true : cost;
/>

abstract sig Sensor extends Classical_Service {}
</
    formula ms_logical_performance_factor;
    formula ms_ram;
    formula ms_bandwidth;
    formula ms_execution_time;
    formula ms_availability;
    formula shots;
    formula performance;
    formula cost;
    enum status_microservice:{initial, done, none};
    var current_status:[status_microservice] init none;
    [machines:pair] (current_status=none) -> (cost'=machines.cpu_cost_factor*ms_availability + machines.qpu_prize*shots) & (performance'=((ms_logical_performance_factor/machines.cpu_logical_performance_factor)+(ms_ram/machines.cpu_ram)+(ms_bandwidth/machines.cpu_bandwidth))/3) & (current_status'=initial);
    [deployment:activationCall] (current_status=initial) -> (current_status'=done);

    // Sumar solo las propiedades cuando se ejecuta
    reward performanceRew [deployment:activationCall] true : performance;
    reward costRew [deployment:activationCall] true : cost;
/>

abstract sig Grover_alg extends Classical_Service {}
</
    formula ms_logical_performance_factor;
    formula ms_ram;
    formula ms_bandwidth;
    formula ms_execution_time;
    formula ms_availability;
    formula shots;
    formula performance;
    formula cost;
    enum status_microservice:{initial, done, none};
    var current_status:[status_microservice] init none;
    [machines:pair] (current_status=none) -> (cost'=machines.cpu_cost_factor*ms_availability + machines.qpu_prize*shots) & (performance'=((ms_logical_performance_factor/machines.cpu_logical_performance_factor)+(ms_ram/machines.cpu_ram)+(ms_bandwidth/machines.cpu_bandwidth))/3) & (current_status'=initial);
    [deployment:activationCall] (current_status=initial) -> (current_status'=done);

    // Sumar solo las propiedades cuando se ejecuta
    reward performanceRew [deployment:activationCall] true : performance;
    reward costRew [deployment:activationCall] true : cost;
/>

abstract sig Quantum_Grover_alg extends Quantum_Service{}
</
    formula ms_logical_performance_factor;
    formula ms_ram;
    formula ms_bandwidth;
    formula ms_execution_time;
    formula ms_availability;
    formula shots;
    formula performance;
    formula cost;
    enum status_microservice:{initial, done, none};
    var current_status:[status_microservice] init none;
    [machines:pair] (current_status=none) -> (cost'=machines.cpu_cost_factor*ms_availability + machines.qpu_prize*shots) & (performance'=((ms_logical_performance_factor/machines.cpu_logical_performance_factor)+(ms_ram/machines.cpu_ram)+(ms_bandwidth/machines.cpu_bandwidth))/3) & (current_status'=initial);
    [deployment:activationCall] (current_status=initial) -> (current_status'=done);

    // Sumar solo las propiedades cuando se ejecuta
    reward performanceRew [deployment:activationCall] true : performance;
    reward costRew [deployment:activationCall] true : cost;
/>

abstract sig Binary_search extends Classical_Service {}
</
    formula ms_logical_performance_factor;
    formula ms_ram;
    formula ms_bandwidth;
    formula ms_execution_time;
    formula ms_availability;
    formula shots;
    formula performance;
    formula cost;
    enum status_microservice:{initial, done, none};
    var current_status:[status_microservice] init none;
    [machines:pair] (current_status=none) -> (cost'=machines.cpu_cost_factor*ms_availability + machines.qpu_prize*shots) & (performance'=((ms_logical_performance_factor/machines.cpu_logical_performance_factor)+(ms_ram/machines.cpu_ram)+(ms_bandwidth/machines.cpu_bandwidth))/3) & (current_status'=initial);
    [deployment:activationCall] (current_status=initial) -> (current_status'=done);

    // Sumar solo las propiedades cuando se ejecuta
    reward performanceRew [deployment:activationCall] true : performance;
    reward costRew [deployment:activationCall] true : cost;
/>

abstract sig Result_processing extends Classical_Service {}
</
    formula ms_logical_performance_factor;
    formula ms_ram;
    formula ms_bandwidth;
    formula ms_execution_time;
    formula ms_availability;
    formula shots;
    formula performance;
    formula cost;
    enum status_microservice:{initial, done, none};
    var current_status:[status_microservice] init none;
    [machines:pair] (current_status=none) -> (cost'=machines.cpu_cost_factor*ms_availability + machines.qpu_prize*shots) & (performance'=((ms_logical_performance_factor/machines.cpu_logical_performance_factor)+(ms_ram/machines.cpu_ram)+(ms_bandwidth/machines.cpu_bandwidth))/3) & (current_status'=initial);
    [deployment:activationCall] (current_status=initial) -> (current_status'=done);

    // Sumar solo las propiedades cuando se ejecuta
    reward performanceRew [deployment:activationCall] true : performance;
    reward costRew [deployment:activationCall] true : cost;
/>
pred show {
//--------------------------------------------------Use-Case----------------------------------------------------------------
// Los servicios de datos de sensores solo están conectados con el servicio agregador y agregador debe estar conectado tambien con datos.
all ds: Sensor,  ag: Aggregator | #(ds.link) = 1 and #(ds.link & Aggregator) > 0 and ds in ag.link and ds not in Grover_alg.link and ds not in Result_processing.link and ds not in Quantum_Grover_alg.link and ds not in Binary_search.link
// Aggregator solo se conecta con ClassicalGrover o con Binary Search
all ag: Aggregator | #(ag.link & Quantum_Grover_alg) = 0 and #(ag.link & Result_processing) = 0 
all cg: Grover_alg, ag: Aggregator | cg in ag.link and ag in cg.link and ag not in cg.hybrid_service.link
// Aggregator solo se conecta con Binary Search
all bs: Binary_search, ag: Aggregator | bs in ag.link and ag in bs.link
// El servicio híbrido está formado por QuantumGrover y ClassicalGrover
all qg: Quantum_Grover_alg, cg: Grover_alg | qg in cg.hybrid_service and cg in qg.hybrid_service
// Para todo Quantum Grover, solo puede estar conectado a servicio ClassicalGrover
// El servicio de procesamiento de resultado, solo está conectado con el servicio Clasico de grover
all rp: Result_processing,  cg: Grover_alg | #(rp.link) = 1 and #(rp.link & Grover_alg) > 0 and rp in cg.link and rp not in Quantum_Grover_alg.link and rp not in Aggregator.link and rp not in Sensor.link 
// El servicio de procesamiento de resultado, solo está conectado con el servicio de Búsqueda Binaria
all rp: Result_processing,  bs: Binary_search | #(rp.link) = 1 and #(rp.link & Binary_search) > 0 and rp in bs.link
// Para todo despliegue híbrido debe haber un grover clásico y un grover cuántico y ningún búsqueda binaria
all hd: Hybrid_Deployment | #(hd.services & Quantum_Grover_alg) = 1 and #(hd.services & Grover_alg) = 1  and #(hd.services & Binary_search) = 0
// Para todo despliegue clásico no debe haber ningún gover clásico ni gover cuántico y un solo búsqueda binaria
all cd: Classical_Deployment | #(cd.services & Quantum_Grover_alg) = 0 and #(cd.services & Grover_alg) = 0  and #(cd.services & Binary_search) = 1
//---------------------------------------------------------------------------------------------------------------------------
all s:Result_processing | #(Result_processing & t3_small) = 0 and #(Result_processing & t3_medium) = 0
all s:Binary_search | #(Binary_search & t3_small) = 0 and #(Binary_search & t3_medium) = 0
all s:Aggregator | #(Aggregator & t3_small) = 0
all s:Grover_alg | #(Grover_alg & t3_small) = 0

}
run show for 25
label done [some Deployment:workflowDone=true]
property rangeR{performanceRew}[F done] totalPerformance;
property rangeR{costRew}[F done] as totalCost;
property SminR{performanceRew}[F done]
property SminR{costRew}[F done]

sig aria_1 extends QPU {}
</
formula cpu_logical_performance_factor = 0;
formula cpu_ram = 0;
formula cpu_bandwidth = 0;
formula cpu_cost_factor = 0;
formula qpu_prize = 0.03;
/>
sig aria_2 extends QPU {}
</
formula cpu_logical_performance_factor = 0;
formula cpu_ram = 0;
formula cpu_bandwidth = 0;
formula cpu_cost_factor = 0;
formula qpu_prize = 0.03;
/>
sig aspen_m_3 extends QPU {}
</
formula cpu_logical_performance_factor = 0;
formula cpu_ram = 0;
formula cpu_bandwidth = 0;
formula cpu_cost_factor = 0;
formula qpu_prize = 0.00035;
/>
sig harmony extends QPU {}
</
formula cpu_logical_performance_factor = 0;
formula cpu_ram = 0;
formula cpu_bandwidth = 0;
formula cpu_cost_factor = 0;
formula qpu_prize = 0.01;
/>
sig lucy extends QPU {}
</
formula cpu_logical_performance_factor = 0;
formula cpu_ram = 0;
formula cpu_bandwidth = 0;
formula cpu_cost_factor = 0;
formula qpu_prize = 0.00035;
/>
sig dm1 extends QPU {}
</
formula cpu_logical_performance_factor = 0;
formula cpu_ram = 0;
formula cpu_bandwidth = 0;
formula cpu_cost_factor = 0;
formula qpu_prize = 0.075;
/>
sig sv1 extends QPU {}
</
formula cpu_logical_performance_factor = 0;
formula cpu_ram = 0;
formula cpu_bandwidth = 0;
formula cpu_cost_factor = 0;
formula qpu_prize = 0.075;
/>
sig local extends QPU {}
</
formula cpu_logical_performance_factor = 0;
formula cpu_ram = 0;
formula cpu_bandwidth = 0;
formula cpu_cost_factor = 0;
formula qpu_prize = 0;
/>
sig t3_large extends CPU {}
</
formula cpu_logical_performance_factor = 5.0;
formula cpu_ram = 8.0;
formula cpu_bandwidth = 5000;
formula cpu_cost_factor = 0.0944;
formula qpu_prize = 0;
/>
sig t3_xlarge extends CPU {}
</
formula cpu_logical_performance_factor = 20.0;
formula cpu_ram = 16.0;
formula cpu_bandwidth = 5000;
formula cpu_cost_factor = 0.1888;
formula qpu_prize = 0;
/>
sig t3_2xlarge extends CPU {}
</
formula cpu_logical_performance_factor = 80.0;
formula cpu_ram = 32.0;
formula cpu_bandwidth = 5000;
formula cpu_cost_factor = 0.3776;
formula qpu_prize = 0;
/>
sig t3_medium extends CPU {}
</
formula cpu_logical_performance_factor = 5.0;
formula cpu_ram = 4.0;
formula cpu_bandwidth = 5000;
formula cpu_cost_factor = 0.0472;
formula qpu_prize = 0;
/>
sig t3_small extends CPU {}
</
formula cpu_logical_performance_factor = 5.0;
formula cpu_ram = 2.0;
formula cpu_bandwidth = 5000;
formula cpu_cost_factor = 0.0236;
formula qpu_prize = 0;
/>
lone sig grover_alg extends Quantum_Grover_alg {}
</
formula ms_logical_performance_factor = 0;
formula ms_ram = 0;
formula ms_bandwidth = 0;
formula ms_execution_time = 0;
formula ms_availability = 0;
formula shots = 1500;
formula performance = 0;
formula cost = 0;
/>
one sig result_processing_0 extends Result_processing {}
</
formula ms_logical_performance_factor = 1e-05;
formula ms_ram = 6;
formula ms_bandwidth = 60.0;
formula ms_execution_time = 100;
formula ms_availability = 24;
formula shots = 0;
formula performance = 0;
formula cost = 0;
/>
lone sig binary_search_0 extends Binary_search {}
</
formula ms_logical_performance_factor = 2.4e-05;
formula ms_ram = 8;
formula ms_bandwidth = 3.6;
formula ms_execution_time = 1;
formula ms_availability = 24;
formula shots = 0;
formula performance = 0;
formula cost = 0;
/>
one sig aggregator_0 extends Aggregator {}
</
formula ms_logical_performance_factor = 4e-06;
formula ms_ram = 4;
formula ms_bandwidth = 240.0;
formula ms_execution_time = 1;
formula ms_availability = 24;
formula shots = 0;
formula performance = 0;
formula cost = 0;
/>
lone sig grover_alg_0 extends Grover_alg {}
</
formula ms_logical_performance_factor = 4e-06;
formula ms_ram = 4;
formula ms_bandwidth = 60.0;
formula ms_execution_time = 10;
formula ms_availability = 24;
formula shots = 0;
formula performance = 0;
formula cost = 0;
/>
one sig sensor_0 extends Sensor {}
</
formula ms_logical_performance_factor = 3e-06;
formula ms_ram = 2;
formula ms_bandwidth = 72.0;
formula ms_execution_time = 1;
formula ms_availability = 24;
formula shots = 0;
formula performance = 0;
formula cost = 0;
/>
one sig sensor_1 extends Sensor {}
</
formula ms_logical_performance_factor = 3e-06;
formula ms_ram = 2;
formula ms_bandwidth = 72.0;
formula ms_execution_time = 1;
formula ms_availability = 24;
formula shots = 0;
formula performance = 0;
formula cost = 0;
/>
one sig sensor_2 extends Sensor {}
</
formula ms_logical_performance_factor = 3e-06;
formula ms_ram = 2;
formula ms_bandwidth = 72.0;
formula ms_execution_time = 1;
formula ms_availability = 24;
formula shots = 0;
formula performance = 0;
formula cost = 0;
/>
